# On March 25, 2025, I had read 70% of ABS guide,
# then I realized that I needed to read it again and take as many notes as possible.

chapter 1 Introduction

I think it is better to read it with the very first chapters of \`bash info\'.
Keywords: Posix, Unix, Shell, Bash, Ksh

Unix shell can interpreter command and execute it.
It provides tons of system utilities and builtin functions for user interface.

Shell, as in interactive mode and non-interactive mode:
What tasks can I accomplish with an interactive shell?
Type command from keyboard and execute them, get result.

What tasks can I accomplish with an non-interactive shell?
Combine system utilities and create powerful script to accomplish complex system tasks.

1. System administrators often write scripts to automate common
tasks. Give several instances where such scripts would be useful.

(1) : Write startup scripts to autoload network configuration files, such as proxy...
(2) : Execute scheduled tasks, such as archiving and cleaning log files. 
(3) : System monitor, e.g. use top to get process statistics and record.

2. Write a script that upon invocation shows the time and date,
   lists all logged-in users, and gives the system uptime. The
   script then saves this information to a logfile.

#!/bin/bash
exec >>~/dummy_logs # 重定向 stdout, 以append模式写入 ~/dummy_logs, 之后的子进程都继承stdout
date; w; uptime;
echo; echo; echo;
exit



chapter 3

character?
literal meaning <-> meta meaning

一个字符可能有多重意义，一个字符在未引用时可能被shell或其他工具赋予其它功能
It is ok to use the literal meaning of a character by escaping or quoting.

One command line is a string, metacharacter separate it to parts, and shell interprete it.

Q: shell展开命令的顺序是什么？ THIS IS VERY IMPORTANT.
一行指令里有variable susbtitution, parameter substitution, command substitution, process substitution时候，
最终得到的字符串是以什么顺序展开的呢？

Very useful yet interesting examples:
eval 'echo `echo "$"{a..b}`'
eval "echo `echo '$'{a..b}`"

关于这个主题的gpt解答:
`command substitution`这种方式会在启动subshell执行命令前先过滤掉backslash
$(command substitution) 这种方式不会

除此之外，$()允许嵌套且可读性好。

我认为，如果command比较简单，比如用tty获取当前终端设备号，那么用``进行command substitution是合适的，如果
command包含复杂的逻辑，比如parameter substitution或者pipe，那么就用$()

还有 parameter/variable expansion 发生在command substitution之前,
所以command substitution的结果中包含的$var 不会被展开

算术展开(()) 在parameter/variable、command substitution 之后。
所以，
在(())结构中使用变量和命令替换 ok。

非字面量的引号 \' \" removal 发生在最后。

通过 $> set -x
观察复杂指令的展开过程
展开顺序 **非常重要**

It seems that bash $' ... ' structure has the same function as escaped character...
But it can even translate original character to unicode character.

$' ... ' 结构有点像"echo -e" 转义, 但是它是展开时就完成转义
用这个可以观察细节
set -x; echo $'\n'
set -x; echo -e '\n'

set +x; # Done

()structure without assignment starts a subshell, in normal case,
the parent bash process cannot access the variable defined in it,
however, we can use process substitution or redirect the output ( to a file ) to get values in it.

Brace expansion will not occur in a quote!
But when it appears in a quote within command substitution, it will happen.

Compare:
echo \|{a..z}\|
echo \| {a..z} \|

Q: 对一个字符串进行base64编码，最终结果可能出现几种字符?
base64编码包括哪64个字符？剩下的那一个字符是什么？有什么用？

base64编码的原理是什么
The base64 encoded form uses printable ASCII chars to represent binary data

About {} structure, from ABS guide:
{ local a; a=233 }; echo $a # ok
local a; a=233 # WRONG! Output an error message

Also from ABS guide:
输入输出重定向将对block 内的所有command生效, 如果一大块代码需要进行重定向，
考虑{ ... } <> fd 结构

difference between '[' and '[[' structure
According to ABS guide, '[[' is more flexible, and...
'[' is a shell builtin ( imagine a function )
'[[' is a shell keyword.
What\'s the difference between builtin and a keyword?
This example illustrate the difference:
eval "[() { echo hello; }; [" # hello
eval "[[() { echo hello; }; [[" # Output error message.
eval "for() { echo 'for is a keyword so this will not output'; }; for" # as mentioned above
eval "while() { echo 'while is a keyword so this will not output'; }; while" # as mentioned above
eval "@() { echo @ is not a keyword; }; @"
Errrrr.... It seems function name restriction is looser than those for variable.

About I/O redirection
一个比较细致的点:
/dev/pts /dev/tty 是(字符)流设备
/path/to/file 是普通文件
流设备中的数据有即时性，写入缓冲区后可立刻供消费端读取, 这又叫做流式读写。
(所以管道两端连接终端设备时可以流畅地串联若干指令，标准流默认都指向终端设备！
一旦在管道中重定向到普通文件，之后的指令无法从标准流中读取数据。即使你把输入流指向文件)
For example:

tty | cat # /dev/pts/X, OK.
tty >./out | cat  # Nothing, 'cause it write output to a file and stdin get nothing from pts.
tty >./out | cat <./out # Nothing, but there is a critical question
tty >>./out | cat <./out
# /dev/pts/X
cat ./out
# /dev/pts/X
# /dev/pts/X
interesting...

tty >./out ; cat <./out # OK, but why? Explain it.
回到这个关键问题：
在shell中在管道中启动两个进程同时读或写一个文件的内容，其行为究竟受什么影响？
我认为其实是受到两个命令执行速度的影响。两个进程实际上不会共享读写文件时的偏移量。
使用shell向linux的文件系统中写入数据，不会发生数据竞争问题，这已经经过时间验证。
shell为管道两边的命令启动subshell并执行，然后连接他们的输出/输入。
如果读取文件的进程执行得较快，它就能输出另一进程修改之前的文件内容。

tty >./out | cat <./out # No output
echo hello >./out | cat <./out # output hello; echo 是builtin, 比cat快得多
echo hello | cat >./out | cat <./out # 偶尔能输出hello :))))

如果想保证读写顺序，用&& 或 || 连接两个命令
关于转义'\r'
echo -e '     you\rkick' # yet rude

yet another interesting fact of IO redirection:
tar cf /dev/stdout . | wc -l # 输出一个数字
tar cf `tty` . | wc -l # 输出一堆东西 然后输出0
然后
tar cf - . 与 tar cf /dev/stdout . 是等价的 ( of course ! )

终端击键Ctrl + D，内核通知EOF,将会退出交互式shell
EOF没有具体的ascii码值

There is a personal clarification about UNIX characters...
Ascii characters can be divided to printable and nonprintable chars;
All printable chars have a literal meaning, as it is.
Some of printable chars have a 'meta' meaning in certain context...
For instance, in bash '~' is refered to $HOME, in cd '-' is refered to $OLDPWD,
'^' and '$' are anchors in regular expression, and most importantly, they have
profound meaning in a vim editor! :)
Nonprintable chars are often used for change behavior of line editing.

Ascii code 1-26 correspond to Ctrl+{A..Z}

shell没有图形输出功能，所以shell必须与terminal结合才能构成基础的用户界面.
shell从标准输入中获取数据，把输出打印到标准输出流，由于默认情况下，标准输入与标准输出
都指向了终端设备，我们才能在显示器上看到输入输出的字符。

GPT wisdom and lore:
控制字符的行为由shell & terminal emulator( or console driver )共同决定。

一些指令，帮助理解shell & terminal在解析控制字符时候的合作：
$> stty -a
intr = ^C; quit = ^\ ...
start = ^Q; stop = ^S ...

$> read -n 1
然后尝试输入控制字符 Ctrl + [A-Z]
Ctrl + C, Ctrl + J, Ctrl + M, Ctrl + Q, Ctrl + S, Ctrl + Z无响应
PS: 如果使用vim terminal, Ctrl + W 后再输入 . 才有响应(why?)

Ctrl + C : Interuppt 中断当前read
Ctrl + J : Line Feed 被shell line editor捕获
Ctrl + M : Carriage Return 同样被line editor捕获
Ctrl + Q : Restart, 被terminal捕获？
Ctrl + S : Stop, 被terminal捕获？
Ctrl + Z : Suspend

由此可见，简单场景下，用户通过键盘发射的原始信号经历了这样的链路：
Keyboard MCU -> Kernel -> Terminal -> Shell -> Foreground program
我认为printable字符也是以这种方式被传输的，但是printable字符不会被terminal解释,
可能被shell解释 ( 比如vi mode )
在交互式shell中输入line feed后，把行缓冲区域的内容提交给shell执行，
shell内部会对这些字符进行进一步的处理

但为什么 Ctrl + H 可以响应???
Ctrl + H & Ctrl + ? 可以响应，说明退格是shell内部行为, 类似vi mode?????

为什么说 'Control characters are not normally useful inside a script.' 呢
因为Control chars被terminal、shell的行编辑器解释执行，在非交互shell中没有特殊意义。

使用`echo`输出Carrige Return的三种方式:
$> echo -e '\r' # C 转义
$> echo $'\x0d' # Hex equivalent
$> echo "^M"    # Ctrl-V Ctrl-M

export IFS 对子进程中的shell无效

chapter 4

IFS分隔在 variable substitution / command substitution 时发生
shell变量可以类比为左右值?

输出 十进制 1 ~ 128 对应的ascii字符:
for i in `seq 1 128`; do
    h=$(printf "%x" $i)
    v=$(echo -e "\x$h")
    echo "$v"
done
yet another gpt wisdom:
Ascii characters:
Null		0x00
Control chars	0x01 ~ 0x1F
Printable	0x20 ~ 0x7E
DEL		0x7F

An example of indirect reference and position parameter:
for i in `seq 1 10`; do
    echo $i; done
for i in `seq 1 10`; do
    echo ${!i}; done

IFS have an effect on command substitution & variable substitution

Characters within double quote will remain literature meaning except '$' '\' and '`'

Yet another example of 'quote':
a=$'\n123\n456'
echo "$(echo $a)"
echo "$(echo "$a")"
这说明了什么?
echo "foo"$a"bar"

现在有一个疑问:
echo "\n" # output \n
echo "\$" # output $
那么escape会对那些chars生效呢:
\\ \` \$ \"

分辨shell转义和command转义：
概念: 通过前缀转义符'\', 某些字符获得了不同的含义，在交互式shell中输入一行指令之后，
首先shell会对这行指令进行转义，将参数传入command后，这些字符可能被command再度转义。
echo '\n' # \n 两个字符作为参数传入echo
echo -e '\n' # 同样的 \n 被传入echo, 但是echo打开了转义选项, 最终输出两个Line Feed

a='abc^H' # ^H is Ctrl-V Ctrl-H, or $'\x08' or '\b'
echo $a
echo -n $a
这说明什么?

关于结构 from `man bash`
if list; then list; [ elif list; then list; ] ... [ else list; ] fi
list 也可以是if 语句,所以下面的代码有效:
if if if [ c ]; then :; fi; then :; fi; then echo farboo; fi # Strike!
这段代码也有效 ':)'
if
a=1
b=2
c=3
((a+b\
==c))
then
echo \
1
else
echo \
2
fi

When naked typed, asterisk('*') has behavior in single bracket and double bracket
test construct.

[ $a = * ] # file globbing will take place
[[ $a = * ]] # partial pattern match, * ? Posix classes make sense

关于 "[" test command 还有一个有趣的细节:
We have already acknowleged that ! reverse the exit state of a command,
but what about '!' within a [ ] construct, what will happen if we combine them?

[ 1 -eq 1 ] && echo True # True
! [ 1 -eq 1] && echo True || echo False # False
! [ ! 1 -eq 1 ] && echo True # True :)

Yet another trick of test command:
[ 1 -eq 2 -a -n "`echo true 1>&2`" ] # Output: true
echo $? # 1

Step 1: echo true 1>&2 # Command Substitution 输出True至终端
Step 2: [ 1 -eq 2 -a -n "" ]

为什么 [[ list1 && list2 ]] 符合短路原则？Why? Tell me why.
What is the difference between '[[' and '['?

chapter 8.2
关于数字常量，一直以来有一个被我忽视的细节:
a=010
echo $a # 010
((a=010))
echo $a # 8
((a=0x10))
echo $a # 16
((a=2#010))
echo $a # 2

分辨数字常量与$' ... ' string-expansion
octal-based and hex-based numberial constants are used in arithmetic expressions

About linux filesystem file mode:
1. You can always check the detail through 'man chmod'
2. Apart from common 'r(ead) w(rite) e(xecute)' file mode, there are setuid/setgid and sticky bit.
3. Execute mode bit in a directory file means it can be searched and entered.
4. setuid/setgid bit is for a regular, executable file, it means other users can execute this file as is its user or group.
5. sticky bit if for a directory, if set, only file owners can delete or rename files within this directory.

chapter 9

关于builtin variables:
$> set 
该命令可以输出所有内建的环境变量,假设想查看BASH开头的所有内建环境变量，可以执行
$> set | grep '^BASH'

printf命令默认对入参执行C风格转义

Yet ANOTHER GPT wisdom:
I wanna to know the difference and precedence of "shell alias, keyword, builtin, hashed command and external command"

First hashed command is a typed command which will be memorized by shell, next time when invoke this command, shell will use its memory, instead of searching PATH.
严格说来, builtin 和 external binary 才算是command吧！

MAX PRECEDENCE
alias
keyword
builtin function
hashed command
external command
MIN PRECEDENCE

alias if='echo hahahahahah'
$> if # hahahahahah
unalias if
$> if # will not output anything
$> if() # syntax error

别名(alias)优先级最高，它不是command
关键字(keyword)拥有语义，构成shell语法结构,也不是command
内建命令(builtin)是shell实现的若干功能，为了减少子进程创建开销(每次执行external command都会拉起外部进程)
缓存命令(hashed command)，当一个命令被执行之后，shell会记录这个命令的位置，下次调用时就会使用缓存的路径而不是再次查询。

Difference between $EUID and $UID
EUID stands for Effective UID, it shows who are running this shell script.
但是在现代unix-like系统的脚本中无法区分EUID和UID,容易被提权攻击
所以似乎EUID is useless...

关于$* $@ and 变量展开
set "a                  b" c # set positional parameter
for i in $*; do echo $i; done
for i in $@; do echo $i; done
for i in $@; do echo "$i"; done
for i in $*; do echo "$i"; done

for i in "$*"; do echo $i; done
for i in "$*"; do echo "$i"; done
for i in "$@"; do echo $i; done
for i in "$@"; do echo "$i"; done

$> IFS=$'\n'
$> a=$'a\nb\nc\nd\n'
$> echo $a
$> echo "$a"

If the variable is expanded without double quoted, it will be separated through $IFS,
the result strings will be concatenated with a single space. THEN PASSED TO COMMAND?

"$*":
结果是把所有形参用IFS中的第一个字符拼起来的字符串
$> set a b  b    c     c       c
$> IFS='^'
$> echo "$*" # a^b^b^c^c^c

$> set "a" "b b" "c c c"
$> IFS='^'
$> echo "$*" # a^b b^c c c

$*:

# Todo: Compare
# $> IFS='^'
# $> set a b^b c c^c
# $> set a "b^b" "c c^c"
# $> a="a b^b c c^c"
# $> echo $a
# $> echo "$a"
# $> for i in $a; do echo $i; done

IFS_ARR=( $'^' $' ^' )
for iter in ${IFS_ARR[@]} ...
for iter in "${IFS_ARR[@]}" ...
for iter in "${IFS_ARR[*]}" ...
有什么不同之处
Compare it with positional parameters, what can we conclude?

Positional parameters puzzles :)

IFS=$'\n \t' # Just adjust the order of original IFS
set a 'b^b' '' 'c c^c'

echo $*
echo "$*"
echo $@
echo "$@"
v=$*
echo "$v"
echo $v
v="$*"
echo "$v"
echo $v
v=$@
echo "$v"
echo $v
v="$@"
echo "$v"
echo $v

Observation 1: "$*" 会把所有parameters用第一个IFS拼接起来, "$@"保留了其作为数组的性质
证据:
arr=( "$*" ) ; echo ${#arr[@]}; # 1
arr=( "$@" ) ; echo ${#arr[@]}; # 4
